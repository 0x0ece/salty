fn main() -> Result<(), Box<dyn std::error::Error>> {

    println!("cargo:rerun-if-changed=build.rs");

    #[cfg(feature = "haase")] {

        // According to the ARMv7-M Architecture Reference Manual,
        // there are two architecture extensions:
        // - the DSP extension: this is what we need, it is also called
        //   "an ARMv7E-M implementation".
        // - the floating-extension: we don't use this
        //
        // The Cortex-M4 processor implements the ARMV7E-M architecture,
        // and according to its Technical Reference Manual (section 3.3.1),
        // the UMAAL instruction takes exactly 1 cycle.
        //
        // In the ARMv8-M Architecture Reference Manual, we read that
        // there are several extensions: main, security, floating-point,
        // DSP,... and that the main extension is a prerequisite for the
        // DSP extension. The Cortex-M33 Technical Reference Manual (section B1.3)
        // states that the DSP extension is optional, so technically
        // `thumbv8m.main-none-eabi[hf]` is not sufficiently specified.
        // It does *not* contain any data on the number of cycles for UMAAL.
        //
        // We treat Cortex-M33 as Cortex-M4 with possibly extra features.

        let target = std::env::var("TARGET")?;
        let mut has_dsp = false;

        if target.starts_with("thumbv7em") {
            println!("cargo:rustc-cfg=cm4");
            has_dsp = true;
        }

        if target.starts_with("thumbv8m.main") {
            println!("cargo:rustc-cfg=cm33");
            has_dsp = true;
        }

        assert!(has_dsp, concat!(
                "\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n",
                "Target `{}` is not a Cortex-M processor with the DSP extension.\n\n",
                "Try running `cargo build (...) --target thumbv7em-none-eabi` (for Cortex-M4) or \n",
                "`cargo build (...) --target thumbv8m.main-none-eabi` (for Cortex-M33).\n",
                "\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n",
                ), target);

        let out_path = std::path::PathBuf::from(std::env::var("OUT_DIR").unwrap());
        std::fs::copy("bin/salty-asm.a", out_path.join("libsalty-asm.a")).unwrap();

        println!("cargo:rustc-link-lib=static={}", "salty-asm");
        println!("cargo:rustc-link-search={}", out_path.display());

        println!("cargo:rerun-if-changed=bin/salty-asm.a");
    }

    #[cfg(feature = "c-api")] {
        // C bindings
        let crate_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();

        cbindgen::Builder::new()
          .with_crate(&crate_dir)
          .with_language(cbindgen::Language::C)
          .with_include_guard("salty_h")
          .with_item_prefix("salty_")
          .with_autogen_warning(concat!(
              "/* Warning, this file is autogenerated by cbindgen. ",
              "Don't modify this manually. */"))
          .generate()
          .expect("Unable to generate bindings")
          .write_to_file("salty.h");

        cbindgen::Builder::new()
          .with_crate(&crate_dir)
          .with_language(cbindgen::Language::Cxx)
          .with_include_guard("salty_h")
          .with_item_prefix("salty_")
          .with_autogen_warning(concat!(
              "/* Warning, this file is autogenerated by cbindgen. ",
              "Don't modify this manually. */"))
          .generate()
          .expect("Unable to generate bindings")
          .write_to_file("salty.hpp");
    }
    Ok(())
}
